f ∘ (g ∘ h) = (f ∘ g) ∘ h

  ((f3 ∘ f2) ∘ f1) (x)
= (f3 ∘ f2) (f1 (x))
= f3 (f2 (f1 (x)))

  f3 ∘ (f2 ∘ f1)
= f3 ∘ (f2 (f1 (x)))
= f3 (f2 (f1 (x)))

True := λt.λf.t
Sequence := λa.λb.b
False    := λt.λf.f

If := λc.λt.λf.c t f (λx.x)

0 := λfx.x                  ≡ λf.λx.x
1 := λfx.f x                ≡ λf.λx.f x
2 := λfx.f (f x)            ≡ λf.λx.f (f x)
3 := λfx.f (f (f x))        ≡ λf.λx.f (f (f x))
...
N := λfx.f (f ... (f x)...) ≡ λf.λx.f (f ... (f x)...)

0 f x ≡ x
1 f x ≡ f x
2 f x ≡ f (f x)
3 f x ≡ f (f (f x))
...
N f x ≡ (f ... (f x)...)

  f (f x) 
≡ (f ∘ f) x

0 := λfx.x                  ≡ λf.λx.x                   ≡ λf.λx.f0 x
1 := λfx.f x                ≡ λf.λx.f x                 ≡ λf.λx.f1 x
2 := λfx.f (f x)            ≡ λf.λx.(f ∘ f) x           ≡ λf.λx.f2 x
3 := λfx.f (f (f x))        ≡ λf.λx.(f ∘ f ∘ f) x       ≡ λf.λx.f3 x
...
N := λfx.f (f ... (f x)...) ≡ λf.λx.(f ∘ f ∘ ... ∘ f) x ≡ λf.λx.fN x

0 f x ≡ f0 x
1 f x ≡ f0 x
2 f x ≡ f0 x
3 f x ≡ f0 x
...
N f x ≡ f0 x

0 := λf.λx.x
1 := λf.λx.f (0 f x)
2 := λf.λx.f (1 f x)
3 := λf.λx.f (2 f x)
...

0 f x ≡ x
1 f x ≡ f x
2 f x ≡ f (f x)
...

Increase := λn.λf.λx.f (n f x)
Increase2 := λn.λf.f ∘ (n f)

Add := λa.λb.λf.λx.a f (b f x)
Add2 := λa.λb.λf.fa ∘ fb ≡ λa.λb.λf.(a f) ∘ (b f)
Add3 := λa.λb.a Increase b

Decrease = λn.λf.λx.n (λg.λh.h (g f)) (λu.x) (λu.u)
Subtract = λa.λb.b Decrease a

Multiply = λa.λb.a (λx.Add b x) 0
Power = λm.λe.e (λx.Multiply m x) 1

IsZero := λn.n (λx.False) True

IsLessOrEqual = λa.λb.IsZero (Subtract a b)
IsGreaterOrEqual = λa.λb.IsZero (Subtract b a)
IsEqual = λa.λb.And (IsLessOrEqual a b) (IsGreaterOrEqual a b)

IsLess := λa.λb.Not (IsGreaterOrEqual a b)
IsGreater := λa.λb.Not (IsLessOrEqual a b)
IsNotEqual := λa.λb.Not (IsEqual a b)

a/b := If a >= b then 1+ (a-b)/b else 0
_DevideBy = λa.λb.If (IsGreaterOrEqual a b) (λx.Add One (_DevideBy (Subtract a b) b)) (λx.Zero)

IsZero := λn.n (λx.False) True
        ≡ λn.n (λx.λt.λf.f) (λt.λf.t)

  IsZero 5
≡ (λn.n (λx.λt.λf.f) (λt.λf.t)) 5
≡ ...

  _DivideBy 10 3
≡ (λa.λb.If (IsGreaterOrEqual a b) (λx.Add One (??? (Subtract a b) b)) (λx.Zero)) 10 3

CreateTuple := λx.λy.λf.f x y
Tuple := λf.f x y
Item1 := λt.t (λx.λy.x)
Item2 := λt.t (λx.λy.y)

  Item1 (Tuple x y)
≡ Item1 (λf.f x y)
≡ (λt.t (λx.λy.x)) (λf.f x y)
≡ (λf.f x y) (λx.λy.x)
≡ (λx.λy.x) x y
≡ (λy.x) y
≡ x

Item1 := λt.t True
Item2 := λt.t False

Decrease = λn.λf.λx.n (λg.λh.h (g f)) (λu.x) (λu.u)

Shift = λf.λt.CreateTuple (Item2 t) (f (Item1 t))

  n Increase Zero
≡ n

  3 (Shift Increase (0, 0))
≡ 3 (Shift Increase) (0, 0)
≡ (Shift Increase) ∘ (Shift Increase) ∘ (Shift Increase) (0, 0)
≡ (Shift Increase) ∘ (Shift Increase) (0, Increase 0)
≡ (Shift Increase) ∘ (Shift Increase) (0, 1)
≡ (Shift Increase) ∘ (1, Increase 1)
≡ (Shift Increase) ∘ (1, 2)
≡ (2, Increase 2)
≡ (2, 3)

  n (Shift Increase (0, 0))
≡ (n - 1, n)

Decrease2 = λn.Item1 (n (Shift Increase) (CreateTuple 0 0))

CreateListNode := λv.λn.λf.f v n
ListNode := λf.f v n
ListNodeValue := λl.l (λv.λn.v)
ListNodeNext := λl.l (λv.λn.n)

ListNodeNext := λl.l (λv.λn.n)

ListNodeNext := λl.If (IsListNodeNull l) λx.l λx.(Item2 l)
ListNodeOfIndex = λl.λi.i ListNodeNext l
NullListNode := λf.λx.x
IsListNodeNull := λl.l (λv.λn.λx.False) True

  IsListNodeNull NullListNode
≡ (λl.l (λv.λn.λx.False) True) (λf.λx.x)
≡ (λf.λx.x) (λv.λn.λx.False) True
≡ (λx.x) True
≡ True

  IsListNodeNull (CreateListNode 0 NullListNode)
≡ IsListNodeNull (λf.f 0 NullListNode)
≡ (λl.l (λv.λn.λx.False) True) (λf.f 0 NullListNode)
≡ (λf.f 0 NullListNode) (λv.λn.λx.False) True
≡ (λv.λn.λx.False) 0 NullListNode True
≡ (λn.λx.False) NullListNode True
≡ (λx.False) True
≡ False

NullListNode := False

CreateListNode2 = λv.λn.CreateTuple False (CreateTuple v n)
ListNode2Value = λl.Item1 (Item2 l)
ListNode2Next = λl.If (IsListNode2Null l) (λx.l) (λx.(Item2 (Item2 l)))

Null = λf.True
IsListNode2Null = λl.(Item1 l)
ListNode2OfIndex = λl.λi.i ListNode2Next l

CreateListNode3 = λv.λn.λf.λx.f v (n f x)
NullListNode3 = f => x => x
IsListNode3Null = λl.l (λv.λx.False) True
ListNode3Value = λl.λx.l (λv.λy.v) x
ListNode3Next = λl.Item2  ((l (λv.λt.CreateTuple (CreateListNode3 v (Item1 t)) (Item1 t)) (CreateTuple NullListNode3 NullListNode3)))
ListNode3OfIndex = λl.λi.i ListNode2Next l

Swap = λt.CreateTuple (Item2 t) (Item1 t)

Sign = numeral => CreateTuple numeral 0

Negate = signed => SwapTuple signed

Positive = signed => Item1 signed
Negative = signed => Item2 signed

FormatWithZero = λs.If (IsEqual sp  sn) (λx.Sign 0) (λx.If(IsGreater sp sn) (λy.(Sign (Subtract sp sn)))(λy.(Negate (Sign (Subtract sn sp)))))

Add = λa.λb.FormatWithZero (CreateTuple (Add ap bp) (Add an bn))

Subtract = λa.λb.FormatWithZero (CreateTuple (Add ap bn) (Add an bp))

Multiply = λa.λb.FormatWithZero (CreateTuple (Add (Multiply ap bp) (Multiply an bn)) (Add (Multiply ap bn) (Multiply an bp)))

DevideBy = λa.λb.FormatWithZero (CreateTuple (Add (DevideByIgnoreZero ap bp) + (DevideByIgnoreZero an bn)) (Add (DevideByIgnoreZero ap bn) (DevideByIgnoreZero an bp))));

DevideByIgnoreZero = λa.λb.If (IsZero b) (λx.0) (λx._DevideBy a b)

 1  ≡ (1, 0) ≡ (2, 1) ≡ (3, 2) ≡ (4, 3) ≡ …
-1  ≡ (0, 1) ≡ (1, 2) ≡ (2, 3) ≡ (3, 4) ≡ …

signedp ≡ Positive signed
signedn ≡ Negative signed

  a + b
≡ (ap, an) + (bp, bn)
≡ (ap - an) + (bp - bn)
≡ (ap + bp, an + bn)

  a - b
≡ (ap, an) - (bp, bn)
≡ (ap - an) - (bp - bn)
≡ (ap + bn, an + bp)

  a * b
≡ (ap, an) * (bp, bn)
≡ (ap - an) * (bp - bn)
≡ (ap * bp + an * bn, ap * bn + an * bp)

  a / b
≡ (ap, an) / (bp, bn)
≡ (ap - an) / (bp - bn)
≡ (ap / bp + an / bn, ap / bn + an / bp)

Encode a rational number q as a pair (numerator, denominator) where k is signed integer, a is natural number, and q = n / (1 + d)
q ：= CreateTuple n d

Signed2 := Tuple
Sign := Item1
Absolute := Item2

MultiplySigned = λa.λb.CreateTuple (Xor (Sign a) (Sign b)) (Multiply (Absolute a) (Absolute b))

True := λt.λf.t
False := λt.λf.f

And :=  λab.a b False
Or :=  λab.a True b
Not := λb.b False True
Xor := λa.λb.a (b False True) (b True False)
If := λc.λt.λf.c t f (λx.x)

Increase := λn.λf.λx.f (n f x)
Increase2 := λn.λf.f ∘ (n f)

Add := λa.λb.λf.λx.a f (b f x)
Add2 := λa.λb.λf.fa ∘ fb ≡ λa.λb.λf.(a f) ∘ (b f)
Add3 := λa.λb.a Increase b

Decrease := λn.λf.λx.n (λg.λh.h (g f)) (λu.x) (λu.u)
Decrease2 := λn.Item1 (n (Shift Increase) (CreateTuple 0 0))

Subtract := λa.λb.b Decrease a

Multiply = λa.λb.a (λx.Add b x) 0

_DevideBy := λa.λb.If (IsGreaterOrEqual a b) (λx.Add One (_DevideBy (Subtract a b) b)) (λx.Zero)
DevideByIgnoreZero = λa.λb.If (IsZero b) (λx.0) (λx._DevideBy a b)

Power = λm.λe.e (λx.Multiply m x) 1

IsZero := λn.n (λx.False) True

IsLessOrEqual := λa.λb.IsZero (Subtract a b)
IsGreaterOrEqual := λa.λb.IsZero (Subtract b a)
IsEqual := λa.λb.And (IsLessOrEqual a b) (IsGreaterOrEqual a b)

IsLess := λa.λb.Not (IsGreaterOrEqual a b)
IsGreater := λa.λb.Not (IsLessOrEqual a b)
IsNotEqual := λa.λb.Not (IsEqual a b)

CreateTuple := λx.λy.λf.f x y
Tuple := λf.f x y
Item1 := λt.t True
Item2 := λt.t False

Shift = λf.λt.CreateTuple (Item2 t) (f (Item1 t))
Swap = λt.CreateTuple (Item2 t) (Item1 t)

CreateListNode := CreateTuple ≡ λv.λn.λf.f v n
ListNode := Tuple ≡ λf.f v n

Value := Item1 ≡ λl.l (λv.λn.v)
Next := Item2 ≡ λl.l (λv.λn.n)

Null := False
IsNull := λl.l (λv.λn.λx.False) True

Index = λl.λi.i Next l

CreateListNode2 = λv.λn.CreateTuple False (CreateTuple v n)

Value2 = λl.Item1 (Item2 l)
Next2 = λl.If (IsNull2 l) (λx.l) (λx.(Item2 (Item2 l)))

IsNull2 = λl.(Item1 l)
Null2 = λf.True

Index2 = λl.λi.i Next2 l

CreateListNode3 = λv.λn.λf.λx.f v (n f x)

Value3 = λl.λx.l (λv.λy.v) x
Next3 = λl.Item2  (l (λv.λt.ShiftTuple (CreateListNode3 v)) (CreateTuple Null3 Null3))

Null3 = λf.λx.x
IsNull3 = λl.l (λv.λx.False) True

Index3 = λl.λi.i Next3 l

Signed := Tuple
ToSigned := λn.CreateTuple n 0
Negate := Swap

Positive := Item1
Negative := Item2

FormatWithZero = λs.If (IsEqual sp  sn) (λx.ToSigned 0) (λx.If (IsGreater sp sn) (λy.ToSigned (Subtract sp sn)) (λy.Negate (ToSigned (Subtract sn sp))))

B := λx.λy.λz.x (y z)
C := λx.λy.λz.x z y
K := λx.λy.   x
W := λx.λy.   x y y

S := λx.λy.λz.x z (y z)
K := λx.λy.   x
I := λx.      x

I2 = S K K
I3 = S K S

(f2 ∘ f1) x := f2 (f1 x)

  S (K f1) f2 x
  (K f1) x (f2 x)
  f1 (f2 x)

  S (K S) K f1 f2 x
≡ (K S) f1 (K f1) f2 x
≡ S (K f1) f2 x
≡ (K f1) x (f2 x)
≡ f1 (f2 x)

Compose := S (K S) K

  K t f
≡ t

  S K t f
≡ K f (t f) 
≡ f

True := K
False := S K

  S K K x
≡ K x (K x)
≡ x

  S K S x
≡ K x (S x)
≡ x

0 := λf.λx.x
1 := λf.λx.f x
2 := λf.λx.f (f x)
3 := λf.λx.f (f (f x))

  K I f x
≡ I x
≡ x

  I f x
≡ f x

  S Compose I f x
≡ Compose f (I f) x
≡ Compose f f x
≡ f (f x)

  S Compose (S Compose I) f x
≡ Compose f (S Compose I f) x
≡ Compose f (Compose f f) x
≡ f (f (f x))

0 := K I                     ≡ K I
1 := I                       ≡ I
2 := S Compose I             ≡ S (S (K S) K) I
3 := S Compose (S Compose I) ≡ S (S (K S) K) (S (S (K S) K) I)
...

Increase := S Compose ≡ S (S (K S) K)

i := λf.f S K ≡ λf.f (λx.λy.λz.x z (y z)) (λx.λy.x)

S := i (i (i (i i)))
K := i (i (i i))
I := i i

  i i x
≡ (λf.f S K) (λf.f S K) x
≡ (λf.f S K) S K x
≡ (S S K) K x
≡ S K (K K) x
≡ K x ((K K) x)
≡ x
≡ I x

ω := λx.x x
Ω := ω ω

  ω ω
≡ (λx.x x) (λx.x x)
≡ (λx.x x) (λx.x x)
...

ω := S I I
Ω := S I I (SII)

  S I I x
≡ I x (I x) 
≡ x x

Ω := S I I (S I I) 
   ≡ I (S I I) (I (S I I)) 
   ≡ I (S I I) (S I I) 
   ≡ S I I (S I I)
   ...


B := S (K S) K
C := S (S (K (S (K S) K)) S) (K K)
K := K
W := S S (S K)

S := B (B (B W) C) (B B) ≡ B (B W) (B B C)
K := K
I := W K

  p
= F p

F := 0 - x

  0
= F 0

  p
= F p
= F (F p)
= ...
= F (F (F … (F p) …))

Y := λf.(λx.f (x x)) (λx.f (x x))

  Y F
= F (Y F)

  Y F
= F (Y F)
= F (F (Y F))
= ...
= F (F (F … (F (Y F)) …))

Y2 := S (K (S I I)) (S (S (K S) K) (K (S I I)))

Y3 = S S K (S (K (S S (S (S S K)))) K

λn.If (IsZero n) (λx.1) (λx.Self (Decrease n))

Factorial := λf.λn.If (IsZero n) (λx.1) (λx.f (Decrease n))
FactorialHelper := λf.λn.If (IsZero n) (λx.1) (λx.f (Decrease n))

Factorial := Y FactorialHelper
           ≡ Y (λf.λn.If (IsZero n) (λx.1) (λx.f (Decrease n)))

Y Factorial n

λn.If (IsGreater n 1) (λx.Add (Self (Subtract n 1)) (Self (Subtract n 2))) (λx.n)

Fibonacci := λf.λn.If (IsGreater n 1) (λx.Add (f (Subtract n 1)) (f (Subtract n 2))) (λx.n)
FibonacciHelper := λf.λn.If (IsGreater n 1) (λx.Add (f (Subtract n 1)) (f (Subtract n 2))) (λx.n)

Fibonacci := Y FibonacciHelper
           ≡ Y (λf.λn.If (IsGreater n 1) (λx.Add (f (Subtract n 1)) (f (Subtract n 2))) (λx.n))

Y Fibonacci n

_DevideBy := λa.λb.If (IsGreaterOrEqual a b) (λx.Add One (_DevideBy (Subtract a b) b)) (λx.Zero)

DevideBy := λf.λa.λb.If (IsGreaterOrEqual a b) (λx.Add One (f (Subtract a b) b)) (λx.Zero)

DevideBy := Y DevideByHelper
          ≡ Y (λf.λa.λb.If (IsGreaterOrEqual a b) (λx.Add One (f (Subtract a b) b)) (λx.Zero))

DevideBy := Y (λf.λa.λb.If (IsGreaterOrEqual a b) (λx.Add One (f (Subtract a b) b)) (λx.Zero))
          ≡ (λf.(λx.f (x x)) (λx.f (x x))) (λf.λa.λb.If (IsGreaterOrEqual a b) (λx.Add One (f (Subtract a b) b)) (λx.Zero))

f1 := λx.Add x 1
f2 := λy.Add y 1

Sequence := λa.λb.b
Sequence (Add 1 2) (Add 3 4)

  Sequence Ω (Add 3 4)
≡ Sequence (ω ω) (Add 3 4)
≡ Sequence ((λx.x x) (λx.x x)) (Add 3 4)
≡ Sequence ((λx.x x) (λx.x x)) (Add 3 4)
≡ ...

IsHalting := λf.λx.If (...f halts on x...) (λx.True) (λx.False)

IsNotHalting := λf.If (IsHalting f f) (λx.Sequence Ω False) (λx.True)

  IsNotHalting f
≡ If (IsHalting f f) (λx.Sequence Ω False) (λx.True))
≡ If (False) (λx.Sequence Ω False) (λx.True))
≡ True

  IsNotHalting f
≡ If (IsHalting f f) (λx.Sequence Ω False) (λx.True))
≡ If (True) (λx.Sequence Ω False) (λx.True))
≡ Sequence Ω False
≡ Sequence (ω ω) False
≡ Sequence ((λx.x x) (λx.x x)) False
≡ Sequence ((λx.x x) (λx.x x)) False
≡ ...

Sequence := False

  IsHalting IsNotHalting IsNotHalting
≡ True

  IsNotHalting IsNotHalting
≡ If (IsHalting IsNotHalting IsNotHalting) (λx.Sequence Ω False) (λx.True)
≡ If (True) (λx.Sequence Ω False) (λx.True)
≡ Sequence Ω False
≡ Sequence (ω ω) False
≡ Sequence ((λx.x x) (λx.x x)) False
≡ Sequence ((λx.x x) (λx.x x)) False
≡ ...

  IsHalting IsNotHalting IsNotHalting
≡ False

  IsNotHalting IsNotHalting
≡ If (IsHalting IsNotHalting IsNotHalting) (λx.Sequence Ω False) (λx.True)
≡ If (False) (λx.Sequence Ω False) (λx.True)
≡ True

GetTrue1 : ≡ λf.λx.λy.Sequence (f x) True
GetTrue2 : ≡ λf.λx.λy.True

  GetTrue1 f x
≡ λy.Sequence (f x) True

  GetTrue2 f x
≡ λy.True

AreEquivalent := λa.λb.If (...a and b are equivalent...) (λx.True) (λx.False)

IsHalting := λf.λx.AreEquivalent (GetTrue1 f x) (GetTrue2 f x)
           ≡ λf.λx.AreEquivalent (λy.Sequence (f x) True) (λy.True)

IsHalting := λf.λx.If (IsEquivalent (λy.Sequence (f y) True) (λy.If (IsEqual y x) (λz.True) (λz.Sequence (f y) True)) (λx.True) (λx.False)
           = λf.λx.If (IsEquivalent (Sequence (f x) True) (True)) (λx.True) (λx.False)

DivideByIgnoreZero = λa.λb.If (IsZero b) (λx.0) (λx._DivideBy a b)

0 := ι ≡ λf.f S K
1 := S(K(S))(K ≡ Compose

S := ι (ι (ι (ι ι)))
K := ι (ι (ι ι))
ι := ι ι

  ι ι x
≡ (λf.f S K) (λf.f S K) x
≡ (λf.f S K) S K x
≡ (S S K) K x
≡ S K (K K) x
≡ K x ((K K) x)
≡ x
≡ ι x